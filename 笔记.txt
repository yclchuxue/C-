C++ 笔记

泛型算法
××××××××××××××××××××××××
为了实现与数据结构的分离，为了实现通用性，算法根本就不知道容器的存在。
算法访问数据的唯一通道是迭代器。是否改变容器大小，完全是迭代器的选择
和责任。当我们向 fill_n 传递 back_inserter 时，虽然最终效果是向
容器添加了新元素，但对 fill_n 来说，根本不知道这回事儿。它仍然像往
常一样（通过迭代器）向元素赋予新值，只不过这次是通过 back_inserter
来赋值，而 back_inserter 选择将新值添加到了容器而已。
××××××××××××××××××××××××

1. find(iter_1, iter_2, val)                //在迭代器iter_1到iter_2之间寻找值val，
                                            //找到则返回一个指向val的迭代器，否则返回
                                            //第儿个参数

2. count(iter_1, iter_2, val)               //在迭代器iter_1到iter_2之间统计值val出
                                            //现的次数，并返回出现的次数，如果没有出现
                                            //则为0

3. accumulate(iter_1, iter_2, val)          //将迭代器iter_1到iter_2之间的所有值加到
                                            //val上，注意加是拼接的意思，例如是string
                                            //类型则运行结束后是一个所有string连接到一
                                            //起的一个string,返回一个val同内型的值。注
                                            //意val一定要支持'+'运算

4. equal(iter_1, iter_2, iter)              //iter_1和iter_2是第一个容器的迭代器，表
                                            //示范围，iter是第二个容器的迭代器，表示开
                                            //始位置，该算法判断，两个序列是否保存相同
                                            //的值，算法默认iter对应容器大于iter_1到
                                            //iter_2，返回0或1

5. fill(iter_1, iter_2, val)                //将迭代器iter_1到iter_2之间的所有值都改
                                            //为val

6. fill_n(iter_1, size, val)                //将从迭代器iter_1开始的size个元素的值改
                                            //为val

7. back_inserter(nums)                      //nums为容器名，该算法返回一个插入迭代器，
                                            //给该插入迭代器赋值相当于向该容器添加元素，

8. copy(iter_1, iter_2, iter)               //iter_1和iter_2是第一个容器的迭代器，表示
                                            //范围iter是第二个容器的迭代器，表示开始位置，
                                            //该算法将iter_1到iter_2之间的元素拷贝到iter
                                            //开始位置之后

9. replace(iter_1, iter_2, val_1, val_2)    //该算法将iter_1到iter_2之间的val_1全部
                                            //修改为val_2（在容器上修改）

10.replace_copy(iter_1, iter_2, iter, val_1, val_2)
                                            //将迭代器iter_1到iter_2之间的所有的值拷贝
                                            //到iter迭代器上，且该范围内的等于val_1的值
                                            //该为val_2，(原容器中不修改)，如果想拷贝到
                                            //一个空容器中，无法使用begin时可以使用插入迭
                                            //代器

11.unique(begin, end)                       //将迭代器范围内，相邻且相同的元素只留一个，
                                            //其他放到容器末尾，并返回指向第一个放到后面
                                            //去的元素的迭代器。可以配合sort排序函数和
                                            //erase删除来去重

12.sort(strs.begin(), strs.end())           //将strs按升序排序

13.sort(strs.begin(), strs.end(), isShorter)//按isSshorter中制定的规则排序(假设规则为按长
                                            //度排序)第三个参数为谓词

14.stable_sort(strs.begin(), strs.end())    //与sort一致

15.stable_sort(strs.begin(), strs.end(), isShorter)
                                            //按isSshorter中制定的规则排序，(假设规则为按
                                            //长度排序)长度相等的保持原顺序不变，第三个参数
                                            //为谓词

16.find_if(iter_1, iter_2, lambda)          //迭代器iter_1和iter_2表示范围，谓词lambda为
                                            //可调用表达式,将iter_1到iter_2中的元素依次带
                                            //入lambda中,直到返回值满足条件

19.for_each(iter_1, iter_2, lambda)         //将迭代器iter_1到iter_2之间的所有值加依次带入
                                            //lambda中.

20.count_if(iter_1, iter_2, lambda)         //将迭代器iter_1到iter_2之间的所有值加依次带入
                                            //lambda中，返回条件为真的个数.

21.