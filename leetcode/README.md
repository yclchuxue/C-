## C++总结

### new 和 alloc 的区别
1.new是C++关键字，需要编译器支持；malloc是库函数，需要头文件支持。

2.使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

3.new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

4.new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。而malloc是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

5.C++允许自定义operator new 和 operator delete 函数控制动态内存的分配[链接](https://blog.csdn.net/jiemashizhen/article/details/125922798)。

6.new做两件事，分别是分配内存和调用类的构造函数，而malloc只是分配和释放内存。new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。

7.new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

8.内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc不可以。

#### new_handler

当operator new申请一个内存失败的时候，它会进行如下的处理步骤：
    1、如果存在客户指定的处理函数，则调用处理函数（new_handler），如果不存在则抛出一个异常。

    2、继续申请内存分配请求。
    3、判断申请内存是否成功，如果成功则返回内存指针，如果失败转向处理步骤1

为了自定义这个“用以处理内存不足”的函数new_handler，用户可以调用set_new_handler进行设置[链接](https://www.cnblogs.com/ljygoodgoodstudydaydayup/p/4209879.html)

#### placement new

placement new：只是operator new重载的一个版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。

如果你想在已经分配的内存中创建一个对象，使用new时行不通的。也就是说placement new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中void* p实际上就是指向一个已经分配好的内存缓冲区的的首地址。[链接](https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html)

### 堆、栈、数据段、代码段

[链接](https://blog.csdn.net/chen1083376511/article/details/54930191)

### 加static是否是线程安全的

1 全局变量、文件域的static变量和类的static成员变量在main函数执行之前初始化
2 局部静态变量在第一次被使用时初始化
3 非局部静态变量是线程安全的
4 局部静态变量在C++11后也是线程安全的

[链接](https://blog.csdn.net/leigelaile1/article/details/121492055)

### 线程池

创建一定的线程，和一个任务队列，线程循环从队列中获取任务进行处理，线程池可以减少创建和销毁进程的消耗；[链接](https://zhuanlan.zhihu.com/p/560291125)

#### 线程同步

线程同步的方式有：

* 互斥锁

优点： 使用简单；
缺点：重复锁定和解锁，每次都会检查共享数据结构，浪费时间和资源；繁忙查询的效率非常低；

* 条件变量

* 读写锁

读写锁 也称之为 共享-独占锁，一般用在读和写的次数有很大不同的场合。即对某些资源的访问会出现两种情况，一种是访问的排他性，需要独占，称之为写操作；还有就是访问可以共享，称之为读操作。

* 信号量

[链接](https://www.cnblogs.com/sherlock-lin/p/14538083.html)

### 多线程和多进程的选择与区别

数据共享、同步
    多进程:数据共享复杂，需要用IPC；数据是分开的，同步简单

    多线程:因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂

内存、CPU
    多进程:占用内存多，切换复杂，CPU利用率低

    多线程:占用内存少，切换简单，CPU利用率高

创建销毁、切换
    多进程:创建销毁、切换复杂，速度慢

    多线程:创建销毁、切换简单，速度很快

编程、调试
    多进程:编程简单，调试简单

    多线程:编程复杂，调试复杂

可靠性
    多进程:进程间不会互相影响

    多线程:一个线程挂掉将导致整个进程挂掉

分布式
    多进程:适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单

    多线程:适应于多核分布式

* 需要频繁创建销毁的优先用线程

* 需要进行大量计算的优先使用线程

* 强相关的处理用线程，弱相关的处理用进程

* 可能要扩展到多机分布的用进程，多核分布的用线程

* 都满足需求的情况下，用你最熟悉、最拿手的方式

[链接](https://blog.csdn.net/lishenglong666/article/details/8557215)

### 进程间通信，分别使用的场景

#### 管道

匿名管道，用完就销毁。命名管道也被叫做 FIFO，因为数据的传输方式是先进先出（first in first out）。管道传输数据是单向的，如果想相互通信，需要创建两个管道才行。

　　缺点：管道的通信方式效率低，不适合进程间频繁地交换数据。

　　优点：简单。

#### 消息队列

缺点：

* 通信不及时
* 不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。
　　
优点：

* 可以频繁地交换数据
* 可以自定义数据类型

#### 共享内存

消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。而共享内存就很好的解决了这一问题。

现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。

共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到，大大提高了进程间通信的速度。

#### 信号量

用了共享内存通信方式，带来新的问题：如果多个进程同时修改同一个共享内存，很有可能发生冲突。例如两个进程都同时写一个地址，先写的进程会的内容会被覆盖。

为了防止多进程竞争共享资源而造成的数据错乱，需要一种保护机制，使得共享的资源在任意时刻只能被一个进程访问。信号量就实现了这一保护机制。

信号量本质是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。

#### 信号

上面说的进程间通信，都是常规状态下的工作模式。对于异常情况下的工作模式，需要用信号的方式来通知进程。

信号跟信号量虽然名字相似，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。

在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。可以通过 kill -l 命令查看所有的信号.

运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。

#### socket

网络通讯

[链接](https://www.cnblogs.com/zhuminghui/p/15405591.html)

### 内存泄露的处理

[内存泄漏](https://youle.zhipin.com/questions/b42775ee3cba80e3tnVz29m6FlQ~.html)：从堆上申请的内存在生命期结束不能交还给操作系统，导致程序私有内存增长的现象

预防:

1.使用智能指针管理内存或者内存池管理内存

2.使用面向对象的方式管理内存，构造申请析构释放

3.使用原生 malloc,free,new，delete 要配对，对于数组释放要使用 delete[]

排查泄露:

1.使用 cppcheck 检查静态内存是否泄露，避免大海捞针找没释放的地方

2.vld 可以查询动态内存泄露

3.其他工具比如 mfc 泄露检查等

4.[使用 mtrace 分析内存泄露](https://zhuanlan.zhihu.com/p/83547768)

### [智能指针的使用](https://blog.csdn.net/cpp_learner/article/details/118912592)

### [多态的概念和实现](https://blog.csdn.net/afei__/article/details/82142775)

[多重继承继续看看](https://blog.csdn.net/zaishuiyifangxym/article/details/88685518)

### 

### 优先队列(priority_queue)
https://blog.csdn.net/weixin_36888577/article/details/79937886
* top 访问队头元素
* empty 队列是否为空
* size 返回队列内元素个数
* push 插入元素到队尾 (并排序)
* emplace 原地构造一个元素并插入队列
* pop 弹出队头元素
* swap 交换内容

升序队列:
```
//对于基础类型 默认是大顶堆

priority_queue<int> a; 

priority_queue <int,vector<int>,greater<int> > q;
```
降序队列
```
//这样就是小顶堆

priority_queue <int,vector<int>,less<int> >q;
```
题目练习:合并K个升序链表